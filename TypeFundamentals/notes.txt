Primitive Types
---------------

Any type the compiler directly supports.
The compiler is able to cast primitive types implicity and explicitly.
Implicit casts are "safe" becuase they do not result in data loss.
Primitive types can be written as literals. A literal is an instace of the type itself.

Overflow Checking
-----------------

C# compiler has overflow checking off by default.
Decimal is not a CLR primitive type.
	There are no overflow specific IL instructions.
	The checked and unchecked operators have no effect.

Value Types
-----------

Value types derive from System.Object > System.ValueType.
Value types are implicitly sealed.
Value types should be immutable.
Value types should be small (16 bytes or less) to reduce memory overhead when passing by value.
Value types are allocated on the heap.
Value types do not have a type object pointer or a sync block index.
Because value types don't have a sync block index it's not possible to have multiple threads synchronise their access to the instance.
The CLR invokes virtual methods (Equals, GetHashCode, ToString) nonvirtually because value types are implicitly sealed.
	Except when you override a virtual method and call the base type's implementation.
		The value type gets boxed.
Calling a nonvirtual method (GetType, MemberwiseClone) required the value type to be boxed becuase these methods are defined by System.Object.

Boxing
------

1) Memory is allocated from the managed heap.
2) The value type's fields are copied to the allocated memory.
3) A pointer to the object (boxed value type) is returned.

Unboxing
--------

Obtaining a pointer to object (boxed value type) on the heap.
	This operation is typically followed by copying the value type's fields into the thread stack.

Equality
--------

http://msdn.microsoft.com/en-us/library/ms173147(v=vs.80).aspx

Hash Codes
----------

http://stackoverflow.com/questions/263400/what-is-the-best-algorithm-for-an-overridden-system-object-gethashcode
http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx

Dynamic
-------

Dynamic is a primitive type.
IL code is produced that describes the desired operation.
	This code is referred to as the payload.
A dynamic expression is really the same type as System.Object.

Any expression can implicilty be cast to dynamic since all expressions result in a type that is derived from System.Object.

object o = 123;
int i = o; // Error: Needs to be explicitly cast from object to int.
int i = (int)o; // Explicit cast from object to int.

dynamic d = 123;
int i = d; // Implicit cast from dynamic to int.

At runtime the C# compiler first checks to see if an object implements the IDynamicMetaObjectProvider interface.
	If yes then the GetMetaObject method is called which returns a DynamicMetaObject derived type.
	If no then the reflection is used.